#include <stdio.h>
#include <stdlib.h>
#include "graph_auth.h"
/**
 * * SECTION: graph-auth
 * * @short_description: A graph login authenticator
 * *
 * * The #GraphAuthPam is a class to authenticate a graph login.
 * */
G_DEFINE_TYPE_WITH_PRIVATE (GraphAuthPam, graph_auth_pam, G_TYPE_OBJECT)

gboolean graph_auth_pam_authenticate(GraphAuthPam* self, gchar* auth_token, gint* err);



#include <security/pam_appl.h>
int
pam_token_pass (int num_msg, const struct pam_message **msg,
                    struct pam_response **resp, void *appdata_ptr){

    for(num_msg--;num_msg >= 0;num_msg--){
        struct pam_response* r;
        r = resp[num_msg];
        if(r != NULL){
            r->resp = appdata_ptr;
        }
    }

    return PAM_SUCCESS;
}

static void
graph_auth_pam_class_init(GraphAuthPamClass* gap_class){

#ifdef DBUS_SERVICE
    //Install interscoption data
    dbus_g_object_type_install_info(graph_auth_pam_TYPE,
                                    &dbus_glib_graph_auth_pam_object_info);
#endif

}

static void
graph_auth_pam_init(GraphAuthPam* self){
    int error = 0;
    GraphAuthPamPrivate* gapp = G_TYPE_INSTANCE_GET_PRIVATE(self, GRAPH_AUTH_PAM_TYPE, GraphAuthPamPrivate);
    struct pam_conv* pam_c = g_malloc(sizeof(struct pam_conv));
    
    pam_c->conv = &pam_token_pass;
    pam_c->appdata_ptr = "aaaaaaaa";

    error = pam_start("graph", "reyad", pam_c, &(gapp->pam_handle));
    if(error != PAM_SUCCESS){
        g_printerr("Error starting pam transaction\n");
    }
}

/**
* graph_auth_pam_new:
* *
* * Allocates a new #GraphAuthPam.
* *
* * Return value: a new #GraphAuthPam.
* */
GraphAuthPam*
graph_auth_pam_new(){
    GraphAuthPam* Auth;

    Auth = g_object_new(GRAPH_AUTH_PAM_TYPE, NULL);

    return Auth;
}


static void
graph_auth_pam_finalize(GObject *object){
   G_OBJECT_CLASS(graph_auth_pam_parent_class)->finalize(object);
}

/**
 * graph_auth_pam_authenticate:
 * @self: Graph Auth instance
 * @auth_token: Authentication token generated by the graph
 * @err: (inout): status code
 * Returns: TRUE on success, FALSE if an error occurred
 **/
gboolean 
graph_auth_pam_authenticate(GraphAuthPam* self, gchar* auth_token, gint* err){
    GraphAuthPamPrivate* gapp = graph_auth_pam_get_instance_private(self);

    GError* error;
    int e = 0;
    char* user = g_malloc(255);

    //struct pam_conv pam_conv;
    char* service = g_malloc(255);

    pam_handle_t* pam_handle = NULL;


    *err = 0;

    pam_handle = gapp->pam_handle;
    if(pam_handle == NULL){
        g_printerr("Error getting PAM!\n" );
        return FALSE;
    }

    e = pam_get_item(pam_handle, PAM_SERVICE, (void*)&service);
    if(e != PAM_SUCCESS){
        g_printerr("Error getting service.\n ERROR  NUM %d\n", e);
        return FALSE;
    } else {
        g_print("got service: %s \n", service);
    }

    e = pam_get_item(pam_handle, PAM_USER, (void*)&user);
    if(e != PAM_SUCCESS){
        g_printerr("Error getting user.\n ERROR  NUM %d\n", e);
        return FALSE;
    } else {
        g_print("got user: %s \n", user);
    }

    e = pam_authenticate(pam_handle, 0);
    if(e != PAM_SUCCESS){
        g_printerr("Error authenticating.\n ERROR  NUM %d\n PAM Error %s\n", e, pam_strerror(pam_handle, e));
        return FALSE;
    }

    g_print("SUCCES AUTHENTICATING");
    
    *err = 1;
    
    return TRUE;
}
