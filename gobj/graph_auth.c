#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#include "graph_auth.h"
/**
 * * SECTION: graph-auth
 * * @short_description: A graph login authenticator
 * *
 * * The #GraphAuthPam is a class to authenticate a graph login.
 * */
G_DEFINE_TYPE_WITH_PRIVATE (GraphAuthPam, graph_auth_pam, G_TYPE_OBJECT)

gboolean graph_auth_pam_authenticate(GraphAuthPam* self, gchar* auth_token, gint* err);



#include <security/pam_appl.h>

const char* PAM_SERVICE_NAME = "graph";

int
pam_token_pass (int num_msg, const struct pam_message **msg,
                    struct pam_response **resp, void *appdata_ptr){
    
    int i;
    GraphAuthPam* self = (GraphAuthPam*) appdata_ptr;
    GraphAuthPamClass* klass = GRAPH_AUTH_PAM_CLASS (G_OBJECT_GET_CLASS(self));
    for(i = 0;i < num_msg;i++){
        struct pam_response* r = resp[i];
        struct pam_message* m = msg[i];

        if(m != NULL){
            if(strncmp(m->msg, "auth_token", 10 ) == 0){
            g_signal_emit (self, klass->new_msg_sigid,0, m->msg, r);
                if(r != NULL){
                    r->resp = self->auth_token;
                }
            }
        }
    }

    return PAM_SUCCESS;
}

static void
graph_auth_pam_class_init(GraphAuthPamClass* klass){

    klass->new_msg_sigid = g_signal_new("new-message",
                                         GRAPH_AUTH_PAM_TYPE,
                                         G_SIGNAL_RUN_LAST | G_SIGNAL_NO_RECURSE | G_SIGNAL_NO_HOOKS,
                                         NULL,
                                         NULL,
                                         NULL,
                                         NULL,//g_cclosure_marshal_VOID__STRING,
                                         G_TYPE_STRING,
                                         1,
                                         G_TYPE_STRING);


#ifdef DBUS_SERVICE
    //Install interscoption data
    dbus_g_object_type_install_info(graph_auth_pam_TYPE,
                                    &dbus_glib_graph_auth_pam_object_info);
#endif

}

static void
graph_auth_pam_init(GraphAuthPam* self){
    int error = 0;

    uid_t uid = getuid();
    char username[0xFF];

    GraphAuthPamPrivate* gapp = G_TYPE_INSTANCE_GET_PRIVATE(self, GRAPH_AUTH_PAM_TYPE, GraphAuthPamPrivate);
    struct pam_conv* pam_c = g_malloc(sizeof(struct pam_conv));
   
    cuserid(username);

    pam_c->conv = &pam_token_pass;
    pam_c->appdata_ptr = self;

    g_print("UID: %d\n", uid);

    error = pam_start(PAM_SERVICE_NAME, username, pam_c, &(gapp->pam_handle));
    if(error != PAM_SUCCESS){
        g_printerr("Error starting pam transaction\n");
    }
}

/**
* graph_auth_pam_new:
* *
* * Allocates a new #GraphAuthPam.
* *
* * Return value: a new #GraphAuthPam.
* */
GraphAuthPam*
graph_auth_pam_new(){
    GraphAuthPam* Auth;

    Auth = g_object_new(GRAPH_AUTH_PAM_TYPE, NULL);

    return Auth;
}


static void
graph_auth_pam_finalize(GObject *object){
   G_OBJECT_CLASS(graph_auth_pam_parent_class)->finalize(object);
}

/**
 * graph_auth_pam_authenticate:
 * @self: Graph Auth instance
 * @auth_token: Authentication token generated by the graph
 * @err: (inout): status code
 * Returns: TRUE on success, FALSE if an error occurred
 **/
gboolean 
graph_auth_pam_authenticate(GraphAuthPam* self, gchar* auth_token, gint* err){
    GraphAuthPamPrivate* gapp = graph_auth_pam_get_instance_private(self);

    GError* error;
    int e = 0;
    char* user = g_malloc(255);

    //struct pam_conv pam_conv;
    char* service = g_malloc(255);

    pam_handle_t* pam_handle = NULL;


    *err = 0;

    pam_handle = gapp->pam_handle;
    if(pam_handle == NULL){
        g_printerr("Error getting PAM!\n" );
        return FALSE;
    }

    self->auth_token = auth_token;

    e = pam_get_item(pam_handle, PAM_SERVICE, (void*)&service);
    if(e != PAM_SUCCESS){
        g_printerr("Error getting service.\n ERROR  NUM %d\n", e);
        return FALSE;
    } else {
        g_print("got service: %s \n", service);
    }

    e = pam_get_item(pam_handle, PAM_USER, (void*)&user);
    if(e != PAM_SUCCESS){
        g_printerr("Error getting user.\n ERROR  NUM %d\n", e);
        return FALSE;
    } else {
        g_print("got user: %s \n", user);
    }

    e = pam_authenticate(pam_handle, 0);
    if(e != PAM_SUCCESS){
        g_printerr("Error authenticating.\n ERROR  NUM %d\n PAM Error %s\n", e, pam_strerror(pam_handle, e));
        return FALSE;
    }

    g_print("SUCCES AUTHENTICATING");
    
    *err = 1;
    
    return TRUE;
}
